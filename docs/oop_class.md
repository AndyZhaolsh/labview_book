# 类

## 创建

在项目浏览器上，点击鼠标右键，选择"新建-\>类"，就可以创建一个新的类：

![images_2/image25.png](images_2/image25.png "新建一个类")

我们给它起个名字叫做“Parent”，因为我们将要使用它当做另一个类的父类。创建新类的时候，LabVIEW会询问新类继承自哪里：

![images_2/image26.png](images_2/image26.png "LabVIEW对象是默认的父类")

作为我们创建的第一个类，我们并没有为它准备一个父类。LabVIEW中所有的类都必须有且仅有一个父类，如果不需要设定一个特别的父类，那么就会默认使用“LabVIEW对象”作为父类。所以“LabVIEW对象”会是LabVIEW中所有类的祖先类，当你编写了一个VI，用于处理所有LabVIEW的对象，比如得到对象的类名，那么输入数据的类型就可以采用“LabVIEW对象”，使得你的程序可以接受任何类型的实例。

接下来我们再使用同样的方法创建一个名为“Child”的类，它是“Parent”的子类，所以选择“Parent”作为它的父类：

![images_2/image27.png](images_2/image27.png "选择父类")


类在结构上是一种特殊的[LabVIEW库](manage_library)，因此它的很多属性和设置都与库相似。比如，类的名字也作为名字空间；也可以为类中的VI设置访问权限等。除此之外，类还有它特殊的设置，比如有属性和方法等。

类被保存在一个以lvclass为后缀名的文件中。

## 方法（VI）

鼠标右键点击在类上，就可以为类创建方法了。方法其实就是一些VI。

![images_2/image28.png](images_2/image28.png "创建新方法")

在新建这一栏下可以看到很多条目：

* VI：就是指创建一个普通的方法VI。
* 虚拟文件夹：如果类中的方法很多，为了便于管理，可以把它们归类到不同的文件夹中。
*属性定义文件夹：这是专用来保存数据读写VI的文件夹。
*基于动态分配模板的VI：如果一个类中的方法，有可能被子类中相同的方法重写，就应该使用这个模板。相当于其它语言中的“虚函数”。
*基于静态分配模板的VI：如果一个类中的方法，不允许被子类重写，就应该使用这个条目来创建。它与基于动态分配模板的VI的唯一的区别在于：动态分配的VI的类输入输出接线端是动态分配的，而静态分配的VI则不是。
*用于数据成员访问的VI：因为类的数据全部是私有的，所以需要借助公有VI来访问它们。这个选项用于快速建立读写类中数据的VI。这些VI依然是基于动态分配模板的VI或基于静态分配模板的VI，只是LabVIEW帮忙在程序框图上添加了一些数据读写的代码。
*用于重写的VI：这个选项是专门给子类用的，用来创建覆盖父类的方法VI。它创建的是一个基于动态分配模板的VI，只是LabVIEW 帮忙在程序框图上添加了一些调用父类同名方法的代码。
*类型定义：创建用户自定义控件，用于自定义一些在模块里可能需要用到的数据类型

下面我们研究一下“基于动态分配模板的VI”和“基于静态分配模板的VI”个子的行为是什么样的

首先在Parent类中创建一个基于静态分配模板的VI，叫做static.vi。这个VI的功能比较简单，只是返回一行文字“Parent Static VI”。

![images_2/image29.png](images_2/image29.png "static.vi")

之后我们尝试在Child类中创建一个同名的基于静态分配模板的VI。这时候就会发现新建的Child.lvclass:static.vi是不能运行的。

![images_2/image30.png](images_2/image30.png "基于静态分配模板的VI不能被覆盖")

点击它的运行按钮，可以看到错误信息：它试图覆盖一个祖先类中的基于静态分配模板的VI。

![images_2/image31.png](images_2/image31.png "静态分配VI被覆盖的错误信息")

所以如果一个类中已经有了一个基于静态分配模板的VI后，它的子孙类中就不能再有同名的方法了。


再创建两个基于动态分配模板的VI，我们可以在父类和子类中分别创建出同名的基于动态分配模板的VI。它们的区别仅在于输出文字略有不同，两个VI都可以正常运行：

![images_2/image32.png](images_2/image32.png "基于动态分配模板的VI")

![images_2/image33.png](images_2/image33.png "父类中的同名VI")

现在我们可以写一个测试程序来看看上面几个VI都会返回什么结果？下图是一个简单的测试，它的程序框图上分别有一个父类的实例，和一个子类的实例，之后分别把它们传递给上面创建的几个VI，看看返回结果：

![images_2/image34.png](images_2/image34.png "测试不同方法的返回值")

上图中，偏紫色图标的VI都属于Parent类，偏黄色图标的VI都属于Child类。

static.vi由于是基于静态分配模板的VI，不能被子孙类覆盖，所以可以确定，被调用的永远是Parent类中的那个static.vi，返回值也一定是“Pareent Static VI”，不论输入的类型是哪一种。

Parent类的实例调用Parent.lvclass:dynamic.vi返回值是“Parent Dynamic VI”；Child类的实例调用Child.lvclass:dynamic.vi返回值是“Child Dynamic VI”。这也是比较确定的。

需要注意的是最后一条测试，“message 6”中的文字：我们把一个Child类的实例泛化成Parent类的一个实例，然后用它去调用dynamic.vi。这里的实例是由Child类生成的，所以不论它在之后的程序中被当做哪个祖先类的实例传递，它都始终是一个Child实例，所以无论之后怎么转换，调用dynamic.vi，运行的都是Child类中的那个dynamic.vi。所以这里返回的文字是“Child Dynamic VI”。只有当子类中没有实现（重写）某个基于动态分配模板的VI，程序才会调用它父类中的同名VI。

下面我们再改动一下Parent.lavclass:static.vi，让它调用Parent.lvclass:dynamic.vi：

![images_2/image35.png](images_2/image35.png "静态VI调用动态VI")

然后我们再在测试VI中，使用一个例泛化成Parent类的实例的Child类的实例调用这个Parent.lavclass:static.vi。返回值会是什么呢？

![images_2/image36.png](images_2/image36.png "测试静态VI调用动态VI")

尽管子类中没有static.vi，测试程序确定调用的是父类中的static.vi，但是由于传入的实例属于Child类，那么static.vi中调用的依然是Child类中的dynamic.vi。一个基于动态分配模板的VI，即便是在其它类的VI中被调用，依然还是会运行实例所属的类中的VI。


这也就是面向对象编程中“多态的含义”。程序在编写的时候，总是使用同父类中的方法，但程序运行时，调用的是哪个方法是根据传入的实例的具体类型来决定的。换句话说，这个被调用的父类的方法是抽象的，它会根据传入对象具体类型的不同表现出多种形态，所以叫做多态。

那么如果一个父类的VI被子类覆盖之后，是不是就无法在子类中被调用了？在子类中调用父类同名方法时，不能如同调用一般的子VI那样，直接把父类的方法拖拽过来。这种调用方式是无效的，而必须使用函数选板中的"编程-\>簇，类与变体-\>调用父类方法"节点来调用父类的方法。如果在新建类的方法时，选择“用于重写的VI”，系统会自动把这个节点加在新生成的VI程序框图上。

![images_2/image37.png](images_2/image37.png "“调用父类方法”节点")

下面是一个改写了的Child.lvclass:dynamic.vi，把父类方法产生的数据与子类方法自己的数据合并返回：

![images_2/image38.png](images_2/image38.png "在子类VI中调用父类的方法")


基于静态分配模板的VI与基于动态分配模板的VI的本文的区别仅在于：动态分配的VI的类输入输出接线端是动态分配的，而静态分配的VI则不是。如果在开始设计的时候，生成了一个基于静态分配模板的VI，但是后来发现它应该是基于动态分配模板的VI，那么也不需要重新在生成一遍，只要改变它的接线端的类型就可以了。
![images/image780.png](images/image780.png “动态分配类输入/输出的接线端”)


## 属性(数据)

除了VI，每个类都包含一个和类同名的.ctl项。尽管它的面板与设置方法与用户自定义控件类似，但实际上在硬盘上是找不到这个.ctl文件的。它的数据信息都直接记录在同名的.lvclass文件中。此外，这个.ctl项必须是一个簇。簇中的元素就是这个类的属性，及它所使用到的数据，这相当于其它语言中的类的变量。与多数其它语言不同之处是，LabVIEW的类的数据只能是私有的。这主要是出于安全考虑。在类之外，只能通过公有的方法来间接访问这些数据。

因为数据都是私有的，所以也不存在继承的问题，子类不能继承父类的数据。如果子类需要使用父类里的数据，也需要通过调用父类提供的方法间接调用。

我们可以为刚刚创建的创建一些数据：

![images_2/image39.png](images_2/image39.png "为类添加数据")

子类和父类中可以添加同名的数据。类的数据可以有初始值设定，初始值就是对应控件的默认值。上图中，如果message控件的默认是空字符串，那么新创建出来的实例中message的数据都是空字符串；如果把message控件的默认值改为字符串“init”，那么新创建出来的实例中message的数据都是“init”。

我们可以使用类的“新建-\>用于数据成员访问的VI”菜单创建一些用于读写数据的VI。

![images_2/image40.png](images_2/image40.png "创建用于读写数据的VI")

新建的数据访问VI也可以选择是动态的或是静态的。因为数据都是私有的，不会有继承的问题，使用静态的数据成员访问VI会更直观一些。唯一的问题是，如果父类和子类中，有重名的数据，它们的数据成员访问VI也会重名，这样如果是静态的VI，就会遇到我们上一节提到的那个“试图覆盖一个祖先类中的基于静态分配模板的VI”的错误。这时候可以给数据访问VI改个名，VI的名字不是必须和数据名相同的。

另一种解决方案是创建动态的数据成员访问VI，这样父类子类中的数据成员访问VI可以重名。还有一个额外的好处是子类中访问父类的数据会更容易理解。LabVIEW的数据不能继承，但现实中有些情况下数据是应当被继承的，比如说父类是“家具”，有个属性“价格”，子类是“桌子”，显然“桌子”应当继承“家具”的价格。在遇到这种情况时，我们可以在父类和子类中添加同名的数据，生成同名的动态数据成员访问VI，以方便在子类动态数据成员访问VI中直接调用父类的同名数据成员访问VI，从而得到父类中的数据。

在设计类的时候应该尽量避免把数据成员访问VI直接给用户使用。模块的一个设计原则就是尽量把底层数据隐藏起来不让用户看到，用户必须通过模块提供的高层方法进行操作，这样模块的开发者才可能放心的对模块底层结构和数据进行维护改进。



## 一个应用示例

### 需求

下面我们使用一个具体的例子来演示一下面向对象编程的整个流程。假设有一家家具店，店里只卖两种家具，桌子和椅子。我们编写一个程序来模拟一下家具店里这些家具的属性和方法。假设我们需要模拟如下的属性和方法：
* 编号（属性）：每个家具都有一个唯一的编号。
* 成本价（属性）：商店进货的价格。
* 返回售价（方法）：每个家具都有一个固定的售价，它等于`家具的成本价格*(预计利润率+1)*(税率+1)`。假设成本价格，利润率和税率都是已知的。
* 组装（方法）：桌子和椅子组装过程。
   *桌子的组装：把桌腿固定在桌面上，然后反转过来。具体过程在演示程序中用一段文字代替即可。
   *椅子的组装：把靠垫和椅背固定在一起，然后再安装椅子腿。具体过程在演示程序中用一段文字代替即可。
* 以上几个属性和方法都是桌子椅子共有的，此外，我们再要求每个类提供一个自己独特的方法：
   * 铺桌布（桌子类的独特方法）：在演示程序中用一段文字表示桌布铺好即可。
   * 放置靠枕（椅子类的独特方法）：在演示程序中用一段文字表示靠枕放好了即可。
   
此外，我们将编写一个模拟程序，调用家具店中每一个家具，打印出它们的售价和承重。

### 设计

根据上面的需求，我们可以做如下的设计
* 需要三个类：家具类，桌子类和椅子类。桌子类和椅子类和椅子类都继承自家具类。
* 家具类包含有两个数据：编号，成本价；两个方法：返回售价，组装。这些是桌子类和椅子类都共同拥有的属性和方法。
   * 返回售价这个方法在所有类中的逻辑都完全相同，所以只需要在父类，家具类中实现，其它两个子类不需要在实现一遍，直接继承父类方法即可。
   * 组装这两个方法虽然是桌子类和椅子类都有的方法，但它的实现在两个类里却不相同，需要分别在两个子类中实现。
   * 我们还将在桌子类和椅子类中各实现一个“初始化”方法，虽然初始化方法在两个子类中同名，但是因为它们的输入参数不同，它们其实是完全不同的方法，所以并不能在父类中定义这个方法。
* 桌子类包含三个方法：初始化（设置产品编号，成本价，和桌布型号），组装，铺桌布。
* 椅子类包含三个方法：初始化（设置产品编号，成本价，和靠枕型号），组装，放置靠枕。
* 此外还需要定义两个常量：利润率和税率


### 创建类

按照上面已经介绍过的方法，创建一个新的项目，然后再创建三个类：分别为Furniture（家具类），Table（桌子类）和Chair（椅子类）。Table和Chair都继承自Furniture。

![images_2/image41.png](images_2/image41.png "家具、桌子和椅子三个类")

### 属性（数据）

家具类Furniture包含两个数据：id（编号）和cost（成本价）。为了在桌子椅子初始化的时候可以设置这两个数据，我们给这两个数据添加了数据访问VI。

![images_2/image42.png](images_2/image42.png "家具类的数据和数据访问方法")

桌子类和椅子类分别需要保存桌布型号（tablecloth_type）和靠枕型号（cushion_model）数据。我们最好为这两个数据定义两个自定义数据类型。自定义的数据类型也可以放在类中保存。比如下图中，桌子类的桌布型号控件就保存在了类中。

![images_2/image43.png](images_2/image43.png "桌子类的数据：桌布型号")


### 方法（VI）

首先实现父类家具类中的方法。返回售价（get_price）方法可被子类直接调用，不需要被子类重写，所以可以使用基于静态分配模板的VI。它的功能就是把家具的成本价乘以利润和交税参数后返回：

![images_2/image44.png](images_2/image44.png "家具类的返回售价方法")

父类家具类中组装（assemble）方法是需要被子类重写的，所以它必须是基于动态分配模板的VI。父类中实现的默认方法仅仅是返回家具的编号：

![images_2/image45.png](images_2/image45.png "家具类的组装方法")

组装方法会被子类重写，比如下图是椅子类中重写的组装方法，它首先调用了父类的同名方法，得到家具的编号，然后插入一段带有“椅子（Chair）”的文字，返回。这样我们将来就能够清楚的知道这个VI被调用过了。桌子类中组装方法的实现类似，就不再贴图了。

![images_2/image46.png](images_2/image46.png "椅子类重写了组装方法")

椅子类中还有一个构造方法（construct.vi），用于初始化椅子的数据。它首先调用家居类中的数据访问VI，设置产品编号和成本价，然后再把靠垫型号写入到椅子类的数据当中去。桌子类已有一个构造方法，与之类似。

![images_2/image47.png](images_2/image47.png "椅子类的构造方法")

椅子类独有的方法是放置靠垫（put_cushion.vi）。我们就让程序读出靠垫的型号，然后返回一段文字表示坐垫放好了。桌子类的铺桌布（put_tablecloth.vi）方法与之类似。

![images_2/image48.png](images_2/image48.png "椅子类的放置靠垫方法")

这样，我们就把用于家具店的几个类都实现好了。下面测试一下看它们是否工作正常。

### 应用测试

首先写一个简单的VI演示为一组椅子放置靠垫，这个VI（put_chair_cushions.vi）功能很简单，输入一组椅子类的实例，分别调用每个实例的放置靠垫方法：

![images_2/image49.png](images_2/image49.png "为一组椅子放置靠垫的VI")

接下来再写一个VI用于组装所有的家具（setup_funitures.vi）。因为这个VI要处理所以类型的家具，它的输入输出控件就不能再是桌子或椅子类了，而必须是家具类型。这个VI稍微复杂一点，首先针对每一个家具调用“组装方法”，再调用“返回售价”方法，再把两个方法返回的字符串合并起来：

![images_2/image50png](images_2/image50.png "组装一组家具的VI")

最后，可以编写用于测试的程序了：

![images_2/image51png](images_2/image51.png "测试程序的程序框图")

这个测试程序大致可以分成三个部分：
* 最左面那一部分是初始化的部分，它调用桌子和椅子类的构造方法，创建了两个椅子对象，和一个桌子对象。
* 中间一部分，把两个椅子的对象放置在了一个数组中，然后传递给 put_chair_cushions.vi 为每个椅子放置靠垫。
* 最右边一部分，把两把椅子和一张桌子防止在了一个数组中，这个数组的数据类型会自动变为家居类的数组，否则无法既存放椅子也存放桌子。

运行这个测试VI，输出结果如下：

![images_2/image52png](images_2/image52.png "测试程序的程序运行结果")

按照传统的编程方式，如果需要对不同的输入对象调用不同方法，需要写一个条件结构，用于判断输入对象的类型，然后按照不同类型去调用不同的子VI。但是，借助类的多态特性，应用程序（测试程序）不再需要程序员编写代码去判断实例数据所属的子类，以及调用不同子VI。在程序中，我们完全可以把所有实例用它们共同的父类的类型来传递，代码中也只使用父类的方法。而程序执行到父类的方法时，会自动执行已经重写了它的相应的子类的方法。

在我们的示例中桌子类和椅子类同时从家具类那里继承了"组装"这个方法。但是，它们都重写了这个方法，这样就实现了多态。尽管setup_funitures.vi的输入控件类型是家具类，但是程序在执行到组装（assemble.vi）这个方法时，会自动判断输入对象的具体类型，然后调用相应的方法，所以我们可以在测试的返回结果中看到桌子类的对象都返回了“Table”字符串，而椅子类的对象都返回了“Chair”字符串。

在程序调用了assemble.vi的地方双击这个子VI，LabVIEW不会像对待普通VI那样立刻打开子VI，而是会列出所有类中的同名VI，询问用户需要看哪一个。    

![images_2/image53png](images_2/image53.png "打开被重写过的子VI")


## 面向对象与数据流

首先考虑一个问题，LabVIEW类的对象在程序中是传值还是传引用的？我们可以做一个简单实验验证一下：

![images_2/image54png](images_2/image54.png "对象的数值传递")

先把一个对象分别传递到两个分支上，在其中一支分叉上修改的数据是不会影响另一分支上的数据的。所以LabVIEW类的对象和LabVIEW中大多数数据类型一样，都是采用值传递的。

LabVIEW是数据流驱动的编程语言。数据在数据线上流动，每个节点通过输入端的连线接收到数据，对其进行处理，再把结果传给输出端连线。为了符合数据流的概念，多数情况下LabVIEW函数或VI使用的传参方式是值传递：就仿佛是整个数据在连线上流动，遇到一个节点，便一股脑儿都传到节点中去。必要时，譬如数据线分叉的时候，数据便生成一个副本。这样就有了两份同样的数据，沿着不同的分支继续传递。

为了保持这种用户已经习以为常的数据流驱动方式，LabVIEW类的对象也是按照值传递的方式在节点间流动的。这一点和其它编程语言是有所差别的。常见文本编程语言中传递对象时，基本都使用传引用的方式。

传值与传引用这两种传参方式各有特色，LabVIEW别具一格地选择了值传递方式，是因为在LabVIEW中，值传递的优势更大一些。

传引用的主要优点在于效率高，一个对象的数据量往往都比较大。C语言中，使用压栈的方式传递函数参数，如果数据量太大，压栈、出栈的开销会非常大。而一个引用类型的数据一般只需要占用4或8个字节，传递它们的开销远小于直接传递数据。而LabVIEW在把参数传递给子VI时，并不是采用压栈方式的。对于设计良好的程序，子VI可以做到缓存重用，也就是子VI中的参数直接使用源数据的内存，这样可以大大提高参数传递的效率。所以，在LabVIEW中，值传递并不像C语言中那样对效率有明显影响。

在多线程程序中，传引用意味着不同的线程可以访问同一块数据。在不同的线程中同时对同一数据进行读写是很危险的，它可能会产生不可预期的结果。所以，在多线程程序中常常使用临界区、信号量等方法来防止竞争状态的出现。这对于C++或其他文本语言的程序员来说，这不是一个太大的问题，编写多线程程序的软件开发人员多少已经对可能出现的竞争状态有所了解。并且他们清楚地知道自己在编写多线程程序，会相当留意并采取措施防止错误出现。

而LabVIEW的使用者中，相当一部分用户是非计算机专业的。为了更简便地利用多线程的优势，LabVIEW采用了自动多线程的机制。编程者并不需要告诉程序开辟新线程，程序中任何两段没有逻辑上先后顺序依赖的代码都有可能被自动地放到两个线程中去同时执行。在这种情况下，传引用是非常危险的，编程者可能根本意识不到程序是多线程的，因而在无意识的情况下写出了存在竞争状态的代码。

只有值传递才可以解决这个问题。值传递意味着数据在必要时，每到一个分叉处，就复制成相等但互相独立的两份数据。每个可能同时运行的数据线上的数据都是相互独立的，程序永远不会试图去同时访问同一个数据。这样就避免了无意识下造成的竞争状态。如果程序中的确需要在不同线程里处理同一对象，编程者可以在明确程序风险的前提下使用LabVIEW中的传引用机制，并做好多线程安全防护。

## 面向对象思想对LabVIEW程序设计的影响

目前，LabVIEW程序开发的一般流程是先设计和实现顶层VI，一般来说顶层VI也就是程序的主界面。然后自上而下地设计和编写LabVIEW程序。在这种思路的引导下，程序中的大部分模块都不具备通用性，都需要重新编写。只有少量最低层的基础程序模块才可能互相通用。

随着程序规模的膨胀，不同项目间的重复度越来越高，可重复利用的东西越来越多。而模块的重用可以极大地提高项目开发效率。因此，对于模块的管理、维护和重用，成了软件开发效率的关键点。程序员不得不把更多的精力集中在模块的设计开发上。

面向对象的编程思想正是应此需求而生的。借助面向对象的编程方法可以对程序的功能模块进行封装，提高模块的通用性和安全性。可以对模块的功能进行继承，提高新模块的开发效率。不同的模块间可以并行地开发、测试，便于团队工作。这些都大大提高了LabVIEW开发大型程序的效率。而搭建在各种模块之上的LabVIEW应用程序，其规模也必然会有一个本质性的飞跃提高。
