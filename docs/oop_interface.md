# 接口

## “类”的种类

LabVIEW为了降低学习门槛，在2020之前，只提供了一种“类”。但是如果我们看一下其它面向对象的编程语言，会发现，它们通常可以实现很多种不同类型的“类”，而且有很多不同的分类方法。

### 访问权限

按照访问权限来分，类的属性（数据）和方法（函数或VI）可以分为：

* 公有：类内和类外都可访问。类内访问是指在同一个类的方法（函数或VI）的代码中可以读写，否则就是类外访问。
* 私有：类内可访问，类外不可访问。
* 保护：可以在类内，或者子类内访问。
* 友元：有的编程语言支持友元的概念，是指某个类的属性和方法可以被其它一些指定为友元的方法或类访问到。

在LabVIEW中，类的属性（数据）只有一种访问权限，私有。数据只能被类内的VI读写。而所有的方法（VI）的访问权限设置：
。。。。

### 是否需要实例化

* 静态：静态的属性和方法不需要类实例化就可以被访问。
* 动态：动态的属性和方法只能通过类的某个实例进行访问。

需要格外注意的是，LabVIEW中的“基于动态分配模板”和“基于静态分配模板”与讨论其它语言时候所说的动态静态完全是不同的概念。按照一般对静态动态的定义，我们之前介绍到的LabVIEW类中的属性和方法都是动态的。之前生成的类的VI的输入控件中都有它所属类，并且是必须的。也就是说，不输入一个类的实例进来，这些VI不能运行。LabIVEW的类中也可以加静态方法，只要添加一个普通的VI，没有类输入的就可以了。比如下图中的VI，它虽然被放置在一个类中，但并没有类的输入，因此可以在任何地方被直接调用。

![images_2/image21.phg](images_2/image21.phg "不需要类实例即可被调用的VI")

这相当于仅仅利用了类的封装特性，把相关的VI封装在类里。有一些VI很适合被封装在类里，比如我们可以制作一个构造VI，它并没有类的输入，但是这个VI可以产生一个类的实例，并且对它进行初始化，比如设置一些初始的数据，打开所需的文件，仪器资源等。下图是一个构造VI的示例：

![images_2/image22.phg](images_2/image22.phg "一个构造VI的前面板")

![images_2/image23.phg](images_2/image23.phg "一个构造VI的程序框图")

### 是否需要或必须被子类覆盖

* 普通函数：大多数语言里，普通的函数对应LabVIEW类中的“基于静态分配模板”VI。这种函数或VI不会被子类中的函数或VI覆盖。
* 虚函数：对应LabVIEW类中的“基于动态分配模板”VI。这种函数或VI会被子类中的函数或VI覆盖。虚函数在子类中被覆盖后仍然是虚函数，如果到某一层级之后不想再让子孙类覆盖了怎么办？有的语言又定义了
* 最终函数：不允许被子类中的函数覆盖。
* 抽象函数：LabVIEW中没有这个概念。抽象函数是一个虚函数，但是它只定义了函数的名字和输入输出参数类型，并没有实现（编写代码给）这个函数。抽象函数需要在子类中实现。

与函数类似，类也有普通类的和抽象类。有些语言里还有最终（final）类。
* 抽象类：不能实例化，只能用于被子类继承。
* 最终类：不能被继承

不能被实例化的类有什么用？举个例子，一家家具店只卖两种家具：桌子和椅子。这时候我们可以定义一个“家具”类，它有两个子类：“桌子”类和“椅子”类。这时候家具就应该是一个抽象类，因为家具店里不存在除了桌子和椅子之外的其它家具类型。为了预防程序员可能出现的错误，把家具类设为抽象类，就会强制使用者从桌子或椅子创建家具实例，不至于创建出一个不知道类型的家具来。
桌子和椅子并不适合被设置为最终类，因为桌椅还可以细分成很多种类，比如躺椅、长条椅等都可以从椅子类派生出来。
最终函数和最终类的使用一般都是处于安全原因，比如我们写了一个用于验证密码的类，为了防止有人把功能被修改了的实例传给调用者，可以把验证密码类设为最终类，放置被继承后在子类里被重写。

## 多继承

LabVIEW的类不允许多继承，一个类只能有一个父类。当然一个类还是可以有多个子类的。但实际应用中，还是会遇到很多需要多继承的情况的。比如还是上面那个家具店，他们只卖坐姿和椅子，但是偏有这么中家具既是桌子也是椅子。

![images_2/image24.phg](images_2/image24.phg "合体桌椅")
