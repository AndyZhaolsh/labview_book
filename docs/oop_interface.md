# 接口


## 接口与类的本质区别

先总结一下类与接口最核心的区别：
* 类的继承是为借用父类已经具有的功能；接口的实现是为了保证类可以提供某些功能。假如，我们为一个型号为LV12345的仪器写了一个类，LV12345类若是继承了**示波器类**，则表示LV12345是一类特殊的示波器，并且它需要借用示波器类已经实现好了的各种功能；如果LV12345类实现了**示波器接口**，那么并不表明LV12345属于任何一类仪器，只表示它将会提供所有示波器所具有的功能。
* 一个类只能继承一个父类；一个类可以实现多个接口。如果LV12345类继承了示波器类，就不能再去继承频谱仪类中实现的方法。LV12345类可以同时实现示波器接口和频谱仪接口，表示它既可以提供示波器的功能，也可以提供频谱仪的功能。

由上可见，我们在应用程序中，需要调用一个功能模块的时候（比如需要调用示波器功能，把输入信号的波形记录下来），那么应该总是使用接口作为输入/输出控件的类型，而不是使用类作为输入/输出控件类型。比如，在应用程序中使用了示波器类做输入输出类型，那么这个应用程序就只能使用示波器，那些新型，不属于示波器却具有示波器功能的仪器都不能被使用。但很明显，应用程序需要的并不是确定的一台示波器，而是任何具有示波器功能的仪器。

## 创建接口

创建新的接口与创建新的类相似：在项目浏览器上，点击鼠标右键，选择"新建-\>接口"，就可以创建一个新的接口。不同的是LabVIEW中所有的类都有一个共同祖先类：“LabVIEW对象”，但是接口不一定有祖先接口。

![images_2/image57.png](images_2/image57.png "新接口没有继承任何其它接口")

接口的文件后缀名也是lvclass，与类文件的后缀名相同。但是在项目中我们经常会遇到需要采用同样名称的类与接口，比如桌子类和桌子接口，这就需要两者有不同的命名。中文可以就以“XX类”，“XX接口”来命名。英文中通常以接口英文Interface的首字母I作为接口名字的前缀，比如用ITable表示桌子接口。LabVIEW并没有对类和接口的名字有特殊要求，只要起名符合公司或组织的规范即可。

接口跟类一样，可以有继承关系，比如我们先创建一个叫做IParent的接口，再创建一个叫做IChildFoo的接口，让它继承IParent：

![images_2/image58.png](images_2/image58.png "子接口继承父接口")

我们接下来创建一些类，并选择他们的接口。父类只能单选，但接口是可以多选的。

![images_2/image59.png](images_2/image59.png "为新创建的类选择需要实现的接口")

## 数据

LabVIEW的接口中不能定义任何数据。

## 方法

创建接口中的方法，与创建类中的方法相同，在接口的新建这一栏下可以看到如下条目：VI、虚拟文件夹、基于动态分配模板的VI、基于静态分配模板的VI、用于重写的VI和类型定义。因为接口中没有数据，所以比类的新建方法少了属性定义文件夹和用于数据成员访问的VI。这些条目中VI、虚拟文件夹、用于重写的VI和类型定义都与类中相对应的条目十分相似。只有基于动态分配模板的VI、基于静态分配模板的VI需要深入探讨一下。

### 接口方法的默认实现

在接口中创建一个基于静态分配模板的VI，意味着这个方法不能被任何子孙接口或类重写。但是它可以被子孙接口和子孙类继承。也就意味着，子孙类的实例是可以直接传递给这个接口中的VI并直接运行的：

![images_2/image60.png](images_2/image60.png "使用一个子类的实例调用接口中实现的VI")

这相当于在接口中添加了一些方法的默认实现，可以共子孙类直接使用。但是由于接口中缺少数据的定义，这个基于静态分配模板的VI不能对，任何对象中数据进行操作，只能做一些并不一定要放在接口中的通用的操作。这导致它对于提高代码效率的帮助十分有限。

一个类的实现的不同接口中可以存在同名的基于静态分配模板的VI。由于这种方法不会被重写，调用关系是非常明确的，不会出现类的多继承造成的调用关系混乱的问题。

### 接口中最常用到的是基于动态分配模板的VI

在接口中创建一个基于动态分配模板的VI，意味着这个方法必须被实现它的类重写。如果不重写，LabVIEW会提示如下的出错信息。

![images_2/image61.png](images_2/image61.png "接口中基于动态分配模板的VI不被重写会出错")

因为必须被重写，所以这个接口里VI的代码是永远不会被执行到的，只有重写了它的类中的方法才会真正被执行。所以，这个接口VI只能用来定义方法的名字和输入/输出参数类型。

一个类的实现的不同接口中可以存在同名并且输入输出参数也相同的基于动态分配模板的VI。因为接口里的基于动态分配模板的VI是必须在类中重写的，所以我们也可以确定，当这个方法被调用的时候，一定是类中的那个方法被调用了。调用关系是非常明确的，也不会出现类的多继承造成的调用关系混乱的问题。

但是这里有几种LabVIEW不支持的情况需要避免：

* 如果一个类的实现的不同接口中存在同名的基于动态分配模板的VI，但是输入输出参数类型不同，这个类是无法被正确实现的。因为重写的VI只能满足一个接口的要求，另一个接口始终无法满足。
* 如果一个类的实现的不同接口中存在同名的VI，但这个VI在某些接口中是静态的，某些接口中是动态的，这个类是无法被正确实现的。因为类中如果不重写这个VI，会出现类没有重写接口中动态VI的错误；而重写了，又会出现重写接口中静态VI的错误。


## 应用示例

再回头考虑我们在上一节，为家具店设计的程序中存在的一些缺陷，比如，不应该让用户生成一个几不属于桌子也不属于椅子的家具；应该允许处理所有处理椅子的程序接受合体桌椅。这些缺陷可以通过引入接口来解决。

我们引入接口并做如下设计：


* 首先我们需要三个接口：家具接口，桌子接口和椅子接口。桌子接口和椅子接口都继承自家具接口。
* 接口中是没有任何数据的，但可以放置用户自定义数据类型的控件。
* 家具接口定义了两个方法：返回售价，组装。这些是桌子接口和椅子接口都共同拥有的方法。
* 桌子接口定义了四个方法：初始化（设置产品编号，成本价，和桌布型号），返回售价，组装，铺桌布。其中，返回售价和组装方法是从家具接口继承来的。
* 椅子接口定义了四个方法：初始化（设置产品编号，成本价，和靠枕型号），返回售价，组装，放置靠枕。其中，返回售价和组装方法是从家具接口继承来的。

程序中会用到桌子的实例，和椅子的实例，因此桌子类和椅子类依然是必须的：

* 桌子类：实现桌子接口定义的所有方法。
* 椅子类：实现椅子接口定义的所有方法。
* 合体桌椅类：实现桌子接口和椅子接口定义的所有方法。

### 创建