# 可重入VI

重入执行是子VI的一个属性。默认情况下，VI是不会被设置这个属性的；需要设置它时，可以在VI属性对话框中，选中"重入执行"选项。设置了这一属性的VI，称为可重入VI。

![](images/image252.png)

图 .12设置VI的可重入属性

如果某个子VI被设置为可重入，那么在程序的不同地方调用这个子VI时，它会在内存中为每一处的调用各生成一个新的VI实例。即，尽管程序在不同地方调用的这个子VI的内容都相同，但是这些子VI在内存中却是相互独立的。如果是非可重入的子VI，在内存中只能有一份实例，所有的调用者都访问这个实例。

被设置为重入执行后，还有两个选项："为各个实例预分配副本"表示每处调用生成的实例VI都拥有各自独立的数据区，它们之间的数据互不干扰。本书后续章节提到的可重入VI，如无特殊说明，都是指这种可重入VI。"在实例间共享副本"是LabVIEW
8.5之后出现的选项，它是指这些实例VI使用同一块数据区。

## 同一VI的并行运行

图
4.13是一个简单的VI，它的程序框图有上下两部分，都调用了同一个子VI。上下两部分的代码之间没有数据线相连。LabVIEW是自动多线程的语言，图中的两个子VI是否会同时运行呢？

![](images/image253.png)

图 .13并行的两个相同子VI

如果程序中调用的是两个不同的子VI，LabVIEW有可能会同时在不同的线程执行它们；但对于两处调用相同的子VI，那就得看子VI是如何设置的了。

如果子VI"简单运算.vi"是非可重入的，那么它们一定不会同时运行。LabVIEW一定要等一个执行完，才会执行另一个。

非可重入的子VI在内存中只有一个实例，它的代码和数据都只有一份。在此处调用这个子VI时，它运行所需的数据内容可能都是不同的。若可以同时运行在多处调用的这个子VI，子VI的运行状态和数据就可能发生混乱。所以LabVIEW要禁止这种情况的发生。

VI的这一特性在有些场合表现出了非常好的优点。比如，一个用于读写某个特定文件的子VI
"foo.txt"。应用程序中可能有多处都调用了这个子VI来读写"foo.txt"，如果允许多个线程的程序同时读写它，就很容易造成其内容的混乱。同一子VI不可在不同线程同时运行的特性恰好保护了"foo.txt"，使它不被不同线程同时读写。

但在某些场合，这一特性又显得非常糟糕。比如，有一个用于读写所有文件的子VI。不同的文件应当是可以同时被访问的，但这个子VI却不允许应用程序同时读写不同的文件。需要同时访问几个文件时，也必须一个一个的访问，暂时不能访问文件的那个线程只好等待着。这样，就造成了程序效率的低下。

在这种场合，需要把子VI设置为可重入，以避开同一子VI不可在不同线程同时运行的特性。一个线程正在运行这个子VI时，另一个线程也可以调用它。在LabVIEW中，形象地来看，就是在程序框图的某处，数据流入了一个子VI；在这个框图另外一处，数据也可以片刻不停地同时流入这个子VI。因此，叫做"可重入"。前面已经讲过，应用程序每处调用可重入的子VI时，都生成了一个独立的实例。这就相当于，在应用程序中各处调用的是不同的子VI，只不过这些子VI内部的代码相同而已。既然是不同的子VI，当然也就可以在不同的线程中同时运行。

图 3.12显示的是一个延时子VI的程序框图（延时1秒），而图
4.14是一个调用了这个延时子VI的应用程序，它并行的调用了这个延时子VI两次，那么这个应用程序总的运行时间是多少呢？

![](images/image254.png)

图 .14计算程序总运行时间

如果延时子VI是非可重入的，则由于两处调用只能先后分别运行，程序总运行时间为2秒。若延时子VI是可重入的，则两处调用可以同时运行，程序总运行时间为1秒。

## 可重入VI的副本

若可重入VI的多个实例共用一份副本，就意味着它们共用同一数据区。不同实例运行时，可能会把不同数据写入这个唯一的数据空间中，这样就造成了数据的混乱。如果需要可重入VI不同实例会同时运行，并且它们运行时会使用不同的数据，那么就一定要把这个子VI设置为"为各个实例预分配副本"。

图
4.15是一个简单的子VI，这个VI的功能是每执行一次，输出的数据加一。它利用了反馈节点。每次运行这个VI时，反馈节点首先输出上次VI运行后传递给它的数据。VI在此基础上加一，再返回给反馈节点，以便下次调用时使用。反馈节点下方的0是它的初始值，第一次调用VI时，反馈节点给出初始值。

![](images/image255.png)

图 .15计算调用次数的子VI

图
4.16是一个调用了“运行次数”子VI的应用程序。执行这个程序后，输出"次数1"和"次数2"分别是几？

![](images/image256.png)

图 .16测试运行次数

运行结果同样与“运行次数”子VI的设置有关。程序中两个循环执行次数一为10，一为20。它们之间没有数据连线，所以可以被同时执行。但哪个循环先执行完是不确定的。

如果“运行次数”子VI是非可重入的，则每次运行程序"次数1"和"次数2"的值是不确定的，但它们之间必然有一个为30。虽然循环运行次序不能确定，但是能够确定，运行次数子VI总共被调用了30次，所以它最后一次被调用后，输出的值一定是30。只不过，哪个循环中的VI是最后一次被调用的并不确定。

如果运行次数子VI是可重入的，并且被设置为"为各个实例预分配副本"，那么图
4.16中程序的执行的结果是确定的。"次数1"的值为10，"次数2"的值为20。由于子VI是可重入的，所以程序中的两处调用行为相当于调用两个不同的子VI。他们分别运行，不论运行次序如何，左侧的子VI被调用了10次，而右侧的子VI被调用了20次。

如果运行次数子VI是可重入的，并且被设置为"在实例间共享副本"。那么图
4.16中程序的执行结果是不确定的："次数1"和"次数2"的值可能是小于30的任何一个数值。子VI可重入意味着程序中的两处子VI调用是可以同时运行的。但是，它们共用一个副本，这就造成了数据的混乱。假如，左侧子VI正在运行，内部记录运行次数的数据是8，而这时右侧子VI也同时运行起来，并往内部记录运行次数的数据区写入一个数值3。这样，左侧子VI再读出该数据是就是一个错误数值了。

"在实例间共享副本"虽然会引起数据的混乱，但是它可以大大节约程序的内存。每生成一个副本，就会多消耗一份内存空间。因此，在确保不会发生数据混乱的情况下可以把可重入子VI设置为"在实例间共享副本"。
