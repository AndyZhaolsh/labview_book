# 接口

## “类”的种类

LabVIEW为了降低学习门槛，在2020之前，只提供了一种“类”。但是如果我们看一下其它面向对象的编程语言，会发现，它们通常可以实现很多种不同类型的“类”，而且有很多不同的分类方法。

### 访问权限

按照访问权限来分，类的属性（数据）和方法（函数或VI）可以分为：

* 公有：类内和类外都可访问。类内访问是指在同一个类的方法（函数或VI）的代码中可以读写，否则就是类外访问。
* 私有：类内可访问，类外不可访问。
* 保护：可以在类内，或者子类内访问。
* 友元：有的编程语言支持友元的概念，是指某个类的属性和方法可以被其它一些指定为友元的方法或类访问到。

在LabVIEW中，类的属性（数据）只有一种访问权限，私有。数据只能被类内的VI读写。而所有的方法（VI）的访问权限设置：
。。。。

### 是否需要实例化

* 静态：静态的属性和方法不需要类实例化就可以被访问。
* 动态：动态的属性和方法只能通过类的某个实例进行访问。

需要格外注意的是，LabVIEW中的“基于动态分配模板”和“基于静态分配模板”与讨论其它语言时候所说的动态静态完全是不同的概念。按照一般对静态动态的定义，我们之前介绍到的LabVIEW类中的属性和方法都是动态的。之前生成的类的VI的输入控件中都有它所属类，并且是必须的。也就是说，不输入一个类的实例进来，这些VI不能运行。LabIVEW的类中也可以加静态方法，只要添加一个普通的VI，没有类输入的就可以了。比如下图中的VI，它虽然被放置在一个类中，但并没有类的输入，因此可以在任何地方被直接调用。

![images_2/image21.phg](images_2/image21.phg "不需要类实例即可被调用的VI")

这相当于仅仅利用了类的封装特性，把相关的VI封装在类里。有一些VI很适合被封装在类里，比如我们可以制作一个构造VI，它并没有类的输入，但是这个VI可以产生一个类的实例，并且对它进行初始化，比如设置一些初始的数据，打开所需的文件，仪器资源等。下图是一个构造VI的示例：

![images_2/image22.phg](images_2/image22.phg "一个构造VI的前面板")

![images_2/image23.phg](images_2/image23.phg "一个构造VI的程序框图")

### 是否需要或必须被子类覆盖

* 普通函数：大多数语言里，普通的函数对应LabVIEW类中的“基于静态分配模板”VI。这种函数或VI不会被子类中的函数或VI覆盖。
* 虚函数：对应LabVIEW类中的“基于动态分配模板”VI。这种函数或VI会被子类中的函数或VI覆盖。
* 抽象函数：LabVIEW中没有这个概念。抽象函数是一个虚函数，但是它只定义了函数的名字和输入输出参数类型，并没有实现（编写代码给）这个函数。抽象函数需要在子类中实现。

与函数类似，类也有普通类的和抽象类。有些语言里还有最终（final）类。
* 抽象类：不能实例化
* 最终类：不能被继承


