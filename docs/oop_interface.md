# 接口


## 接口与类的本质区别

先总结一下类与接口最核心的区别：
* 类的继承是为借用父类已经具有的功能；接口的实现是为了保证类可以提供某些功能。假如，我们为一个型号为LV12345的仪器写了一个类，LV12345类若是继承了**示波器类**，则表示LV12345是一类特殊的示波器，并且它需要借用示波器类已经实现好了的各种功能；如果LV12345类实现了**示波器接口**，那么并不表明LV12345属于任何一类仪器，只表示它将会提供所有示波器所具有的功能。
* 一个类只能继承一个父类；一个类可以实现多个接口。如果LV12345类继承了示波器类，就不能再去继承频谱仪类中实现的方法。LV12345类可以同时实现示波器接口和频谱仪接口，表示它既可以提供示波器的功能，也可以提供频谱仪的功能。

由上可见，我们在应用程序中，需要调用一个功能模块的时候（比如需要调用示波器功能，把输入信号的波形记录下来），那么应该总是使用接口作为输入/输出控件的类型，而不是使用类作为输入/输出控件类型。比如，在应用程序中使用了示波器类做输入输出类型，那么这个应用程序就只能使用示波器，那些新型，不属于示波器却具有示波器功能的仪器都不能被使用。但很明显，应用程序需要的并不是确定的一台示波器，而是任何具有示波器功能的仪器。

## 创建接口

创建新的接口与创建新的类相似：在项目浏览器上，点击鼠标右键，选择"新建-\>接口"，就可以创建一个新的接口。不同的是：LabVIEW中所有的类都有一个共同祖先类：“LabVIEW对象”，但是接口没有这个选项。但是在LabVIEW的内部实现中，LabVIEW对象也是所有接口的祖先。

![images_2/image57.png](images_2/image57.png "新接口没有继承任何其它接口")

接口的文件后缀名也是lvclass，与类文件的后缀名相同。但是在项目中我们经常会遇到需要采用同样名称的类与接口，比如桌子类和桌子接口，这就需要两者有不同的命名。中文可以就以“XX类”，“XX接口”来命名。英文中通常以接口英文Interface的首字母I作为接口名字的前缀，比如用ITable表示桌子接口。LabVIEW并没有对类和接口的名字有特殊要求，只要起名符合公司或组织的规范即可。

接口跟类一样，可以有继承关系，比如我们先创建一个叫做IParent的接口，再创建一个叫做IChildFoo的接口，让它继承IParent：

![images_2/image58.png](images_2/image58.png "子接口继承父接口")

我们接下来创建一些类，并选择他们的接口。父类只能单选，但接口是可以多选的。

![images_2/image59.png](images_2/image59.png "为新创建的类选择需要实现的接口")

## 属性

LabVIEW的接口中不能定义任何数据。接口用来定义一个类具有哪些外部可用的数据和方法，但是LabVIEW中的类中的数据都是私有的，不能被外部使用，也就自然不能在接口中定义任何数据。

## 方法

创建接口中的方法，与创建类中的方法相同，在接口的新建这一栏下可以看到如下条目：VI、虚拟文件夹、基于动态分配模板的VI、基于静态分配模板的VI、用于重写的VI和类型定义。因为接口中没有数据，所以比类的新建方法少了属性定义文件夹和用于数据成员访问的VI。这些条目中VI、虚拟文件夹、用于重写的VI和类型定义都与类中相对应的条目十分相似。只有基于动态分配模板的VI、基于静态分配模板的VI需要深入探讨一下。

### 基于静态分配模板的VI

在接口中创建一个基于静态分配模板的VI，意味着这个方法不能被任何子孙接口或类重写。但是它可以被子孙接口和子孙类继承。也就意味着，子孙类的实例是可以直接传递给这个接口中的VI并直接运行的：

![images_2/image60.png](images_2/image60.png "使用一个子类的实例调用接口中实现的VI")

这相当于在接口中添加了一些方法的默认实现，可以共子孙类直接使用。但是由于接口中缺少数据的定义，这个基于静态分配模板的VI不能对，任何对象中数据进行操作，只能做一些并不一定要放在接口中的通用的操作。这导致它对于提高代码效率的帮助十分有限。

一个类的实现的不同接口中可以存在同名的基于静态分配模板的VI。由于这种方法不会被重写，调用关系是非常明确的，不会出现类的多继承造成的调用关系混乱的问题。

### 基于动态分配模板的VI

在接口中创建的基于动态分配模板的VI，默认是要求必须被实现它的类重写的。如果不重写，LabVIEW会提示如下的出错信息。

![images_2/image61.png](images_2/image61.png "接口中基于动态分配模板的VI不被重写会出错")

一般来说，我们不需要要改动这个设置。这样，这个接口中的VI必须被重写，所以它的代码是永远不会被执行到的，只有重写了它的类中的方法才会真正被执行。因此，接口的动态VI一般只用来定义方法的名字和输入/输出参数类型。一个类实现的不同接口中可以存在同名并且输入输出参数也相同的基于动态分配模板的VI。又因为接口里的基于动态分配模板的VI是必须在类中重写的，所以我们也可以确定，当这个方法被调用的时候，一定是类中的那个方法被调用了。调用关系是非常明确的，也不会出现类的多继承造成的调用关系混乱的问题。

默认的设置下，意味着接口中基于动态分配模板的VI，不能提供方法的默认实现。正如我们前面提到的，接口中方法能做的事情非常有限，即便提供了默认实现，也不会对编程提供太大帮助。当然，如果一定想要使用接口中基于动态分配模板的VI默认实现也是可以的，只要把“必须被子孙类重写”的设置去掉就好了。这样，子孙类中就可以继承接口中方法的默认实现了。LabVIEW对接口中方法默认实现的多继承也做了限制，当某一个类实现的不同接口中有同名的，不需要被子孙类重写的动态VI，子孙类也必须重写这个方法。这样将来不管哪一个程序使用到这个类的对象的时候，都可以明确的知道调用的是这个类当中重写了的方法，而不是调用到了任何一个接口中实现的方法。这样就避免了，在多继承中搞不清楚是调用关系的问题。

LabVIEW对于过于复杂的情况，程序员有可能搞不清楚的情况，一般都会报错，以避免可能出现的风险。比如一下几种情况：
* 如果一个类的实现的不同接口中存在同名的基于动态分配模板的VI，但是输入输出参数类型不同，这个类是无法被正确实现的，始终汇报错。因为重写的VI只能满足一个接口的要求，另一个接口始终无法满足。
* 如果一个类的实现的不同接口中存在同名的VI，但这个VI在某些接口中是静态的，某些接口中是动态的，这个类是无法被正确实现的。因为类中如果不重写这个VI，会出现类没有重写接口中动态VI的错误；而重写了，又会出现重写接口中静态VI的错误。

LabVIEW在功能上所做的限制，可能会使得它无法实现一些比较常见的应用。假设有一台型号叫做LV12345的仪器，它同时具有示波器和频谱仪的功能。我们在程序里也定义了示波器接口和频谱仪接口，这两个接口各自定义了一个方法叫做“初始化”。如果两个接口定义的初始化方法如果参数不同，LV12345类是无法同时实现两个接口的。即便两个接口中的初始化方法名字，参数类型都相同，但所需的功能不同，比如示波器的初始化需要把一个仪器开关设置到1；和频谱仪的初始化需要把同一个开关设置到2，那么LV12345类只能实现一个初始化方法，而且无法知道它是在被示波器接口调用还是被频谱仪接口调用。

所以我们在设计接口时，需要考虑尽可能避免在相关的接口中出现同名的方法。甚至可以给方法的名字取得长一些，比如示波器接口中的方法叫做“初始化示波器”；频谱仪接口中的方法叫做“初始化频谱仪”。

### 访问权限

接口中的VI与类中的VI有类似的访问权限设置。但是，我们要考虑到，定义接口的目的，就是为了确定一个模块具有那些外部可以调用的功能。其它功能最好都不要放在接口里，这也就是说，保持默认的共有访问权限即可。

总结下来，为了减少程序潜在的风险，我们使用接口时，应当尽量：
* 只定义模块（实现这个接口的类）的那些供外部调用的共有方法。
* 只使用基于动态分配模板的VI。
* 方法名应该尽量包含细节，以避免可能的名字冲突。

## 应用示例

再回头考虑一下我们在[介绍LabVIEW的类](oop_class)一节中为家具店设计的程序，它存在的一些明显的缺陷，比如，不应该让用户生成一个既不属于桌子也不属于椅子的家具；应该允许处理所有处理椅子的程序接受合体桌椅。这些缺陷可以通过引入接口来解决。

我们引入接口并对设计做如下修改：

* 首先我们需要三个接口：家具接口，桌子接口和椅子接口。桌子接口和椅子接口都继承自家具接口。
* 接口中是没有任何数据的，但可以放置用户自定义数据类型的控件。
* 家具接口定义了两个方法：返回售价，组装。这些是桌子接口和椅子接口都共同拥有的方法。
* 桌子接口定义了三个方法：返回售价，组装，铺桌布。其中，返回售价和组装方法是从家具接口继承来的。
* 椅子接口定义了三个方法：返回售价，组装，放置靠枕。其中，返回售价和组装方法是从家具接口继承来的。

程序中会用到桌子的实例，和椅子的实例，因此桌子类和椅子类依然是必须的：

* 桌子类：实现桌子接口定义的所有方法，和一个初始化方法（设置产品编号，成本价和桌布型号）。
* 椅子类：实现椅子接口定义的所有方法，和一个初始化方法（设置产品编号，成本价和靠枕型号）。

初始化这个方法，并没有一个类类型的输入，无法把它写作一个基于动态分配模板的VI，也就无法在接口中定义它。此外我们增加一个合体桌椅类，用来演示一个类实现多个接口。并且我们会给它添加一些测试。

* 合体桌椅类（ChairWithTableAttached）：实现桌子接口和椅子接口定义的所有方法，和一个初始化方法（设置产品编号，成本价，桌布型号和靠枕型号） 。

### 创建

创建接口和类的过程之前已经介绍过，不再赘述。打开LabVIEW的“查看->LabVIEW类层次结构”可以看到新的程序中的接口和类的继承关系如下：

![images_2/image62.png](images_2/image62.png "接口和类的继承关系")

## 属性

与之前纯使用类来实现的示例相比，在这个演示中，我们使用家具接口替代了家具类。好处是可以防止用户直接生成一个我们不支持的家具对象，但缺点是我们无法把所有家具公用的数据方法的实现放在接口里，因此，数据和方法的实现不得不被分别挪到了底层了类当中去。比如新的示例中，桌子类，椅子类和合体桌椅类都需要各自添加编号、成本价等本可共用的数据。

![images_2/image63.png](images_2/image63.png "每个类都要各自添加一些本可共用的数据")

之前在家具类中实现的可共用的数据访问功能也需要在每个类中分别实现一份。

## 方法

由于接口中定义的方法，默认状态下是要求必须在类中重写的，如果某个类缺少了接口定义方法的重写，LabVIEW汇报错。方法的实现前文已介绍过，这里不再赘述。

## 应用测试





（不同类型的祖先，多个不同祖先？）