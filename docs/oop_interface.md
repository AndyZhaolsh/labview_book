# 接口

## “类”的种类

LabVIEW为了降低学习门槛，在2020之前，只提供了一种“类”。但是如果我们看一下其它面向对象的编程语言，会发现，它们通常可以实现很多种不同类型的“类”，而且有很多不同的分类方法。

### 访问权限

按照访问权限来分，类的属性（数据）和方法（函数或VI）可以分为：

* 公有：类内和类外都可访问。类内访问是指在同一个类的方法（函数或VI）的代码中可以读写，否则就是类外访问。
* 私有：类内可访问，类外不可访问。
* 保护：可以在类内，或者子类内访问。
* 友元：有的编程语言支持友元的概念，是指某个类的属性和方法可以被其它一些指定为友元的方法或类访问到。

在LabVIEW中，类的属性（数据）只有一种访问权限，私有。数据只能被类内的VI读写。而所有的方法（VI）的访问权限设置：
。。。。
底层的方法（VI）要尽量设置成私有的，不能够让用户直接使用。在LabVIEW还没有私有VI设置功能的时候，笔者经常遇到的一个问题是：有时候修改了一个底层的VI，很快就会有用户抱怨说，笔者的改动破坏了他们的应用程序，他们没办法再像原来那样使用被改动过的VI了。笔者会觉得很委屈，这些VI本来就不是给你们用的呀。可是没有办法，用户就是上帝嘛，只能把改动回退回去。这样就造成功能模块非常难以维护，每一处都有可能影响到一些客户，都不能动。如果把底层的VI都设置为私有的，这样就能够确保用户不会使用它们。在维护的时候就可以放心的去修改他们了。

### 是否需要实例化

* 静态：静态的属性和方法不需要类实例化就可以被访问。
* 动态：动态的属性和方法只能通过类的某个实例进行访问。

需要格外注意的是，LabVIEW中的“基于动态分配模板”和“基于静态分配模板”与讨论其它语言时候所说的动态静态完全是不同的概念。按照一般对静态动态的定义，我们之前介绍到的LabVIEW类中的属性和方法都是动态的。之前生成的类的VI的输入控件中都有它所属类，并且是必须的。也就是说，不输入一个类的实例进来，这些VI不能运行。LabIVEW的类中也可以加静态方法，只要添加一个普通的VI，没有类输入的就可以了。比如下图中的VI，它虽然被放置在一个类中，但并没有类的输入，因此可以在任何地方被直接调用。

![images_2/image21.png](images_2/image21.png "不需要类实例即可被调用的VI")

这相当于仅仅利用了类的封装特性，把相关的VI封装在类里。有一些VI很适合被封装在类里，比如我们可以制作一个构造VI，它并没有类的输入，但是这个VI可以产生一个类的实例，并且对它进行初始化，比如设置一些初始的数据，打开所需的文件，仪器资源等。下图是一个构造VI的示例：

![images_2/image22.png](images_2/image22.png "一个构造VI的前面板")

![images_2/image23.png](images_2/image23.png "一个构造VI的程序框图")

### 是否需要或必须被子类覆盖

* 普通函数：大多数语言里，普通的函数对应LabVIEW类中的“基于静态分配模板”VI。这种函数或VI不会被子类中的函数或VI覆盖。
* 虚函数：对应LabVIEW类中的“基于动态分配模板”VI。这种函数或VI会被子类中的函数或VI覆盖。虚函数在子类中被覆盖后仍然是虚函数，如果到某一层级之后不想再让子孙类覆盖了怎么办？有的语言又定义了
* 最终函数：不允许被子类中的函数覆盖。
* 抽象函数：LabVIEW中没有这个概念。抽象函数是一个虚函数，但是它只定义了函数的名字和输入输出参数类型，并没有实现（编写代码给）这个函数。抽象函数需要在子类中实现。

与函数类似，类也有普通类的和抽象类。有些语言里还有最终（final）类。
* 抽象类：不能实例化，只能用于被子类继承。
* 最终类：不能被继承

不能被实例化的类有什么用？举个例子，一家家具店只卖两种家具：桌子和椅子。这时候我们可以定义一个“家具”类，它有两个子类：“桌子”类和“椅子”类。这时候家具就应该是一个抽象类，因为家具店里不存在除了桌子和椅子之外的其它家具类型。为了预防程序员可能出现的错误，把家具类设为抽象类，就会强制使用者从桌子或椅子创建家具实例，不至于创建出一个不知道类型的家具来。
桌子和椅子并不适合被设置为最终类，因为桌椅还可以细分成很多种类，比如躺椅、长条椅等都可以从椅子类派生出来。
最终函数和最终类的使用一般都是处于安全原因，比如我们写了一个用于验证密码的类，为了防止有人把功能被修改了的实例传给调用者，可以把验证密码类设为最终类，放置被继承后在子类里被重写。

## 多继承

### 多继承的问题
LabVIEW的类不允许多继承，一个类只能有一个父类。当然一个类还是可以有多个子类的。但实际应用中，还是会遇到很多需要多继承的情况的。比如还是上面那个家具店，他们只卖坐姿和椅子，但是偏有这么种家具，它既是桌子也是椅子：

![images_2/image24.png](images_2/image24.png "合体桌椅")

这种合体桌椅即有桌子的属性和方法，也有椅子的属性和方法，最符合直觉的就是它应该同时有两个父类：“桌子”类和“椅子”类。它应该把两个父类的属性和方法都继承来，如果只能单继承，比如只能继承自椅子类，那么它具有的桌子的属性和方法，就要再重新编程实现一遍，比较低效。其实还有个比低效更严重的问题，如果某个程序是用来处理桌子的，程序只能输入桌子的实例，由于这个合体桌椅是继承自椅子类，就无法把他传给程序做处理了。

有些编程语言，是允许多继承的，比如C++。但是多继承引发了很多更为严重的问题，比如属性和方法冲突的问题。在多继承的情况下，我们可以写一个“合体桌椅”类，同时继承桌子和椅子。桌子和椅子类中可能会有一些同名的方法，那么合体桌椅类应该继承谁的呢？
* 有时候可能需要同时保留两个父类里同名的方法，比如桌子和椅子都有“返回承重”方法，可以得到家具的承重参数，“合体桌椅”类的桌子部分和椅子部分还是有不同承重的，所以需要同时保留来自两个父类的“返回承重”方法；
* 有时候可能应该在两个父类的同名方法中只保留一份，比如桌子和椅子都有“返回价格”方法，合体桌椅也不可能一个东西返回两样价格。
* 更麻烦的情况是，有一个程序用于处理所有的家具，它的输入数据类型是“家具”，当有一把合体桌椅被当做“家具”类的实例传递给程序后，程序调用了实例的“返回承重”方法，这时候你觉得程序会拿到合体桌椅从桌子类那里继承来的方法，还是从椅子类那里继承来的方法，还是最早他们共同从“家具”类里继承来的方法？

其实，编程语言肯定会把这些情况都定义的明明白白，问题程序员搞不清楚。程序员会写出能产生各种莫名其妙结果的代码，以至于使用多继承产生的问题远比它解决的问题多。学习C++编程经常看到的一个建议就是尽量不要使用多继承。再C++之后的一些主流编程语言直接就取消了类的多继承。既不能使用类的多继承，有需要合体桌椅同时被处理桌子的程序和处理椅子的程序都接受，怎么办呢？解决方法是使用“接口”。

### 接口

我们可以把接口想象为只包含抽象函数的抽象类。接口可以被多继承而不引起混乱，因为接口中只有方法的定义，而没有实现。我们可以明确的知道程序不会调用到接口里的方法，因为哪里没有实现方法的代码。当一个类继承了一个父类，那么它是为了借用父类实现好的方法做事情；当一个类继承了一个接口，它是保证会自己会实现接口要求的所有方法。一个类当然可以继承多个接口，保证自己会支持每个接口定义的所有方法。合体桌椅同时继承“桌子”接口和“椅子”接口，那么就可以同时被处理桌子的程序和处理椅子的程序接受了。

接口虽然解决了同一个一个类的实例，被多种处理不同类型的程序接受的问题。但是他并没有解决，如何有效降低重复代码的问题。不同的编程语言采取了一些不同的措施来更有效的重复利用代码。比如在PHP语言中引入了一种叫做trade的东西。一个treat就是一个代码块儿，不同的类都可以使用某1tree的，当使用一个trait的时候。 Treat的里边所有的代码就都会被 copy到调用它的类当中。一个treat里的代码，有可能被多个类使用，比如说。我们有一段代码是给table treat的。写字台类和餐桌类同时都使用了这个trade，那么当程序运行的时候我们会发现。假如垂中有一个函数叫做。返回价格。那么在程序运行的时候，我们会发现写字台类和餐桌类都拥有了这个返回价格方法。这两个方法各自属于写字台类和餐桌类，在程序中并看并不能看到有这么一个桌子，treat这样一个端东西。
 Java在解决这个问题的时候，采取了另一种策略，他允许在接口中添加一些函数的默认的实线，也就是说接口中的函数不再全部都是抽象函数了，有些函数是被实现出来的。当某一个类。实现了这个接口也就自然的继承了，这个已经实现好了的方法。这就重新又会引起多继承的问题，我们在多继承里讨论的那个问题。
 Java的解决方法是强制要求，如果。某一个类在他所实现的不同的接口当中，拥有同名的方法的时候。这个累必须重写这个方法，覆盖原来在接口中定义的默认方法。这样将来不管哪一个程序使用到这个实例的时候，都可以明确的知道调用的是这个实例当中重写了的这个方法，而不是调用到了某一个接口中实现的方法。这样就避免了，在多继承中搞不清楚是调用哪个父类的方法的问题。
接口
